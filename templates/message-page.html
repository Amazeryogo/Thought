{% extends "base.html" %}

{% block content %}
<div class="container py-5">
  <div class="row justify-content-center">
    <div class="col-md-8 col-lg-6">
      <div class="card shadow rounded-4 chat-wrapper">
        <div class="chat-header p-3 fw-bold border-bottom">
          Chat with <a href="/{{ username }}" class="text-decoration-none">{{ username }}</a>
        </div>
        <div id="chat-box" class="chat-messages p-3" style="max-height: 400px; overflow-y: auto;">
          <!-- Messages will be appended here -->
        </div>
        <div class="chat-input p-3 border-top">
          <form onsubmit="event.preventDefault(); sendMessage();">
            <div class="input-group">
              <input id="chatInput" type="text" class="form-control" placeholder="Type your message...">
              <input type="file" id="mediaInput" class="d-none" accept="image/png, image/jpeg, image/gif, video/mp4, video/webm">
              <label for="mediaInput" class="btn btn-secondary mb-0">
                <span class="material-symbols-outlined">perm_media</span>
              </label>
              <button class="btn btn-primary" type="submit">
                <span class="material-symbols-outlined">send</span>
              </button>
            </div>
          </form>
        </div>
      </div>
    </div>
  </div>
</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
<script>
  function md5(string) {
  return CryptoJS.MD5(string).toString();
}

const username = "{{ username }}";
const currentUser = "{{ current_user.username }}";
const chatBox = document.getElementById("chat-box");
const input = document.getElementById("chatInput");

function formatMessage(msg) {
  const messageDiv = document.createElement("div");
  messageDiv.classList.add("d-flex", "mb-3");
  if (msg.sender === currentUser) {
    messageDiv.classList.add("justify-content-end", "text-end");
  }

  const avatar = document.createElement("img");
  avatar.src = `/avatar/${msg.sender}`;
  avatar.alt = "avatar";
  avatar.classList.add("rounded-circle", "me-2");
  avatar.style.width = "40px";
  avatar.style.height = "40px";

  const messageContent = document.createElement("div");
  messageContent.classList.add("bg-light", "p-2", "rounded", "shadow-sm");
  messageContent.innerHTML = `
    <div class="fw-bold small">${msg.sender}</div>
    <div>${msg.message}</div>
    <div class="small text-muted mt-1">${msg.timestamp}</div>
  `;

  const reactionsDiv = document.createElement("div");
  reactionsDiv.classList.add("d-flex", "mt-2");

  if (msg.reactions) {
    for (const emoji in msg.reactions) {
      const reactionBadge = document.createElement("span");
      reactionBadge.classList.add("badge", "bg-secondary", "me-1");
      reactionBadge.textContent = `${emoji} ${msg.reactions[emoji].length}`;
      reactionBadge.style.cursor = "pointer";
      reactionBadge.onclick = () => reactToMessage(msg._id, emoji);
      reactionsDiv.appendChild(reactionBadge);
    }
  }

  const addReactionButton = document.createElement("button");
  addReactionButton.classList.add("btn", "btn-sm", "btn-outline-secondary");
  addReactionButton.textContent = "+";
  addReactionButton.onclick = () => showEmojiPicker(msg._id, addReactionButton);
  reactionsDiv.appendChild(addReactionButton);

  messageContent.appendChild(reactionsDiv);

  if (msg.media) {
    if (msg.media.toLowerCase().endsWith(('.mp4', '.webm'))) {
        const video = document.createElement("video");
        video.src = msg.media;
        video.classList.add("img-fluid", "rounded", "mt-2");
        video.controls = true;
        messageContent.appendChild(video);
    } else {
        const image = document.createElement("img");
        image.src = msg.media;
        image.classList.add("img-fluid", "rounded", "mt-2");
        messageContent.appendChild(image);
    }
  }


  if (msg.sender === currentUser) {
    const deleteButton = document.createElement("button");
    deleteButton.classList.add("btn", "btn-sm", "btn-outline-danger", "ms-2", "d-none");
    deleteButton.innerHTML = "&times;";
    deleteButton.onclick = () => deleteMessage(msg._id);

    messageDiv.onmouseover = () => deleteButton.classList.remove("d-none");
    messageDiv.onmouseout = () => deleteButton.classList.add("d-none");

    messageContent.insertBefore(deleteButton, messageContent.firstChild);

    messageDiv.appendChild(messageContent);
    messageDiv.appendChild(avatar);
  } else {
    messageDiv.appendChild(avatar);
    messageDiv.appendChild(messageContent);
  }

  return messageDiv;
}

async function fetchMessages() {
  try {
    const res = await fetch(`/messages6?with=${encodeURIComponent(username)}`);
    const data = await res.json();
    if (!Array.isArray(data)) throw new Error("Invalid data format");

    chatBox.innerHTML = "";
    data.forEach(msg => {
      chatBox.appendChild(formatMessage(msg));
    });
    chatBox.scrollTop = chatBox.scrollHeight;
  } catch (e) {
    console.error("Failed to load messages", e);
  }
}

async function sendMessage() {
  const content = input.value.trim();
  const mediaFile = document.getElementById("mediaInput").files[0];

  if (!content && !mediaFile) {
    return; // Don't send empty messages
  }

  let mediaUrl = null;
  if (mediaFile) {
    const formData = new FormData();
    formData.append("image", mediaFile); // The endpoint expects 'image'

    const res = await fetch("/api/upload/message_image", {
      method: "POST",
      body: formData
    });

    const data = await res.json();
    if (data.success) {
      mediaUrl = data.image_url; // The endpoint returns 'image_url'
    } else {
      alert("Failed to upload media: " + data.error);
      return;
    }
  }

  const res = await fetch("/api/send_message", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ username, message: content, media: mediaUrl })
  });

  if (res.ok) {
    input.value = "";
    document.getElementById("mediaInput").value = ""; // Clear the file input
    await fetchMessages();
  } else {
    alert("Failed to send message");
  }
}

fetchMessages();
setInterval(fetchMessages, 5000);

function showEmojiPicker(messageId, button) {
  const existingPicker = document.querySelector(".emoji-picker");
  if (existingPicker) {
    existingPicker.remove();
  }

  const emojiPicker = document.createElement("div");
  emojiPicker.classList.add("emoji-picker");
  const emojis = ["👍", "❤️", "😂", "😢", "😮"];
  emojis.forEach(emoji => {
    const emojiSpan = document.createElement("span");
    emojiSpan.textContent = emoji;
    emojiSpan.style.cursor = "pointer";
    emojiSpan.style.padding = "5px";
    emojiSpan.onclick = () => {
      reactToMessage(messageId, emoji);
      emojiPicker.remove();
    };
    emojiPicker.appendChild(emojiSpan);
  });

  document.body.appendChild(emojiPicker);
  const rect = button.getBoundingClientRect();
  emojiPicker.style.position = "absolute";
  emojiPicker.style.top = `${rect.top - emojiPicker.offsetHeight - 10}px`;
  emojiPicker.style.left = `${rect.left}px`;
  emojiPicker.style.backgroundColor = "white";
  emojiPicker.style.border = "1px solid #ccc";
  emojiPicker.style.padding = "5px";
  emojiPicker.style.borderRadius = "5px";
  emojiPicker.style.boxShadow = "0 2px 5px rgba(0,0,0,0.1)";

  // Close picker when clicking outside
  setTimeout(() => {
    document.addEventListener("click", (event) => {
      if (!emojiPicker.contains(event.target) && event.target !== button) {
        emojiPicker.remove();
      }
    }, { once: true });
  }, 0);
}

async function reactToMessage(messageId, emoji) {
  const res = await fetch("/api/message/react", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ message_id: messageId, emoji: emoji })
  });

  if (res.ok) {
    await fetchMessages();
  } else {
    alert("Failed to react to message");
  }
}

async function deleteMessage(messageId) {
  if (confirm("Are you sure you want to delete this message?")) {
    const res = await fetch(`/deletemsg?msg_id=${messageId}&redirect={{username}}`);
    if (res.redirected) {
      window.location.href = res.url;
    } else {
      // If the server doesn't redirect, we can at least update the UI
      await fetchMessages();
    }
  }
}
</script>
{% endblock %}
