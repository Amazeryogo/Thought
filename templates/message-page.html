{% extends "base.html" %}

{% block content %}
<div class="container py-5">
  <div class="row justify-content-center">
    <div class="col-md-8 col-lg-6">
      <div class="card shadow rounded-4 chat-wrapper">
        <div id="new-message-indicator" class="alert alert-info" style="display: none; position: absolute; bottom: 80px; left: 50%; transform: translateX(-50%); cursor: pointer; z-index: 10;">
            New messages
        </div>
        <div class="chat-header p-3 fw-bold border-bottom">
          Chat with <a href="/{{ username }}" class="text-decoration-none">{{ username }}</a>
          <span id="online-status" class="ms-2 small"></span>
        </div>
        <div id="chat-box" class="chat-messages p-3" style="max-height: 400px; overflow-y: auto;">
          <!-- Messages will be appended here -->
        </div>
        <div class="chat-input p-3 border-top">
          <form onsubmit="event.preventDefault(); sendMessage();">
            <div class="input-group">
              <input id="chatInput" type="text" class="form-control" placeholder="Type your message...">
              <input type="file" id="mediaInput" class="d-none" accept="image/png, image/jpeg, image/gif, video/mp4, video/webm">
              <label for="mediaInput" class="btn btn-secondary mb-0">
                <span class="material-symbols-outlined">perm_media</span>
              </label>
              <button class="btn btn-primary" type="submit">
                <span class="material-symbols-outlined">send</span>
              </button>
            </div>
          </form>
        </div>
      </div>
    </div>
  </div>
</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
<script>
  function md5(string) {
  return CryptoJS.MD5(string).toString();
}

const username = "{{ username }}";
const currentUser = "{{ current_user.username }}";
const chatBox = document.getElementById("chat-box");
const input = document.getElementById("chatInput");

function formatMessage(msg) {
  const messageDiv = document.createElement("div");
  messageDiv.classList.add("d-flex", "mb-3");
  if (msg.sender === currentUser) {
    messageDiv.classList.add("justify-content-end", "text-end");
  }

  const avatar = document.createElement("img");
  avatar.src = `/avatar/${msg.sender}`;
  avatar.alt = "avatar";
  avatar.classList.add("rounded-circle", "me-2");
  avatar.style.width = "40px";
  avatar.style.height = "40px";

  const messageContent = document.createElement("div");
  messageContent.classList.add("p-2", "rounded", "shadow-sm");
  messageContent.innerHTML = `
    <div class="fw-bold small">${msg.sender}</div>
    <div>${msg.message}</div>
    <div class="small text-muted mt-1">${msg.timestamp}</div>
  `;

  const reactionsDiv = document.createElement("div");
  reactionsDiv.classList.add("d-flex", "mt-2");

  if (msg.reactions) {
    for (const emoji in msg.reactions) {
      const reactionBadge = document.createElement("span");
      reactionBadge.classList.add("badge", "bg-secondary", "me-1");
      reactionBadge.textContent = `${emoji} ${msg.reactions[emoji].length}`;
      reactionBadge.style.cursor = "pointer";
      reactionBadge.onclick = () => reactToMessage(msg._id, emoji);
      reactionsDiv.appendChild(reactionBadge);
    }
  }

  messageContent.appendChild(reactionsDiv);

  const emojiPicker = document.createElement('div');
  emojiPicker.className = 'emoji-picker-hover';
  emojiPicker.style.position = 'absolute';
  emojiPicker.style.top = '-20px';
  emojiPicker.style.right = '0';
  emojiPicker.style.display = 'none';
  emojiPicker.style.backgroundColor = 'white';
  emojiPicker.style.border = '1px solid #ccc';
  emojiPicker.style.borderRadius = '5px';
  emojiPicker.style.padding = '2px';
  emojiPicker.style.zIndex = '10';

  const emojis = ["ðŸ‘", "â¤ï¸", "ðŸ˜‚", "ðŸ˜¢", "ðŸ˜®"];
  emojis.forEach(emoji => {
      const emojiSpan = document.createElement("span");
      emojiSpan.textContent = emoji;
      emojiSpan.style.cursor = "pointer";
      emojiSpan.style.padding = "3px";
      emojiSpan.onclick = () => reactToMessage(msg._id, emoji);
      emojiPicker.appendChild(emojiSpan);
  });

  messageContent.style.position = 'relative'; // Needed for absolute positioning of child
  messageContent.appendChild(emojiPicker);

  messageContent.addEventListener('mouseenter', () => {
      emojiPicker.style.display = 'block';
  });

  messageContent.addEventListener('mouseleave', () => {
      emojiPicker.style.display = 'none';
  });

  if (msg.media) {
    const lowerCaseMedia = msg.media.toLowerCase();
    if (lowerCaseMedia.endsWith('.mp4') || lowerCaseMedia.endsWith('.webm')) {
        const video = document.createElement("video");
        video.src = msg.media;
        video.classList.add("img-fluid", "rounded", "mt-2");
        video.controls = true;
        messageContent.appendChild(video);
    } else {
        const image = document.createElement("img");
        image.src = msg.media;
        image.classList.add("img-fluid", "rounded", "mt-2");
        messageContent.appendChild(image);
    }
  }


  if (msg.sender === currentUser) {
    const deleteButton = document.createElement("button");
    deleteButton.classList.add("btn", "btn-sm", "btn-outline-danger", "ms-2", "d-none");
    deleteButton.innerHTML = "&times;";
    deleteButton.onclick = () => deleteMessage(msg._id);

    messageDiv.onmouseover = () => deleteButton.classList.remove("d-none");
    messageDiv.onmouseout = () => deleteButton.classList.add("d-none");

    messageContent.insertBefore(deleteButton, messageContent.firstChild);

    messageDiv.appendChild(messageContent);
    messageDiv.appendChild(avatar);
  } else {
    messageDiv.appendChild(avatar);
    messageDiv.appendChild(messageContent);
  }

  return messageDiv;
}

let isLoadingMore = false;
let firstMessageId = null;
let lastMessageId = null;

async function fetchMessages(before = null) {
    if (isLoadingMore && before) return; // prevent multiple loads when scrolling
    isLoadingMore = true;

    let url = `/messages6?with=${encodeURIComponent(username)}`;
    if (before) {
        url += `&before=${before}`;
    }

    try {
        const res = await fetch(url);
        const data = await res.json();
        if (!Array.isArray(data)) throw new Error("Invalid data format");

        if (data.length > 0) {
            if (!before) { // Initial load
                chatBox.innerHTML = "";
                 data.forEach(msg => {
                    chatBox.appendChild(formatMessage(msg));
                });
                chatBox.scrollTop = chatBox.scrollHeight;
                firstMessageId = data[0]._id;
                lastMessageId = data[data.length - 1]._id;

            } else { // Prepending older messages
                const oldScrollHeight = chatBox.scrollHeight;
                data.forEach(msg => {
                    chatBox.insertBefore(formatMessage(msg), chatBox.firstChild);
                });
                chatBox.scrollTop = chatBox.scrollHeight - oldScrollHeight;
                firstMessageId = data[0]._id;
            }
        }
    } catch (e) {
        console.error("Failed to load messages", e);
    } finally {
        isLoadingMore = false;
    }
}

chatBox.addEventListener('scroll', () => {
    if (chatBox.scrollTop === 0 && !isLoadingMore) {
        console.log("loading more messages");
        fetchMessages(firstMessageId);
    }
});

async function sendMessage() {
  const content = input.value.trim();
  const mediaFile = document.getElementById("mediaInput").files[0];

  if (!content && !mediaFile) {
    return; // Don't send empty messages
  }

  let mediaUrl = null;
  if (mediaFile) {
    const formData = new FormData();
    formData.append("image", mediaFile); // The endpoint expects 'image'

    const res = await fetch("/api/upload/message_image", {
      method: "POST",
      body: formData
    });

    const data = await res.json();
    if (data.success) {
      mediaUrl = data.image_url; // The endpoint returns 'image_url'
    } else {
      alert("Failed to upload media: " + data.error);
      return;
    }
  }

  const res = await fetch("/api/send_message", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ username, message: content, media: mediaUrl })
  });

  if (res.ok) {
    input.value = "";
    document.getElementById("mediaInput").value = ""; // Clear the file input
    await fetchMessages();
  } else {
    alert("Failed to send message");
  }
}

fetchMessages();

setInterval(async () => {
    const res = await fetch(`/messages6?with=${encodeURIComponent(username)}`);
    const data = await res.json();
    if (data.length > 0 && lastMessageId && data[data.length - 1]._id !== lastMessageId) {
        const isScrolledToBottom = chatBox.scrollHeight - chatBox.clientHeight <= chatBox.scrollTop + 1;
        if (!isScrolledToBottom) {
            newMessageIndicator.style.display = 'block';
        } else {
            // User is at the bottom, so just refresh the messages
            fetchMessages();
        }
    }
}, 5000);

newMessageIndicator.addEventListener('click', () => {
    fetchMessages(); // This will reload the chat and scroll to bottom
    newMessageIndicator.style.display = 'none';
});

async function reactToMessage(messageId, emoji) {
  const res = await fetch("/api/message/react", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ message_id: messageId, emoji: emoji })
  });

  if (res.ok) {
    await fetchMessages();
  } else {
    alert("Failed to react to message");
  }
}

async function deleteMessage(messageId) {
  if (confirm("Are you sure you want to delete this message?")) {
    const res = await fetch(`/deletemsg?msg_id=${messageId}&redirect={{username}}`);
    if (res.redirected) {
      window.location.href = res.url;
    } else {
      // If the server doesn't redirect, we can at least update the UI
      await fetchMessages();
    }
  }
}

async function updateUserStatus() {
    try {
        await fetch('/api/user/active', { method: 'POST' });
    } catch (e) {
        console.error("Failed to update user status", e);
    }
}

async function fetchUserStatus() {
    try {
        const res = await fetch(`/api/user/{{ username }}/status`);
        const data = await res.json();
        const statusSpan = document.getElementById("online-status");
        if (data.online) {
            statusSpan.textContent = "Online";
            statusSpan.classList.add("text-success");
            statusSpan.classList.remove("text-muted");
        } else {
            statusSpan.textContent = `Last seen: ${data.last_seen}`;
            statusSpan.classList.add("text-muted");
            statusSpan.classList.remove("text-success");
        }
    } catch (e) {
        console.error("Failed to fetch user status", e);
    }
}

// Update user status every minute
setInterval(updateUserStatus, 60000);
updateUserStatus(); // Initial update

// Fetch other user's status every minute
setInterval(fetchUserStatus, 60000);
fetchUserStatus(); // Initial fetch

</script>
{% endblock %}
